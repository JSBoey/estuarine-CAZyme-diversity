---
title: "Analyses (ver. 2)"
author: "Jian Sheng Boey"
format: 
  html:
    fig-format: svg
    fig-width: 12
    fig-height: 9
execute: 
  cache: true
filters: 
  - include-code-files
---

# Environment

::: {callout-note}
The following are run as part of `.Rprofile`.
:::

```{r}
#| eval: false

dynamicRequire <- function(lib) {
  if (!require(lib, character.only = TRUE)) install.packages(lib)
  library(lib, character.only = TRUE, quietly = TRUE, verbose = FALSE)
  invisible(lib)
}
dynamicRequire <- Vectorize(dynamicRequire)

libs <- c(
  # Fast utilities
  "Rfast", "Rfast2",
  # Ecology
  "vegan",
  # Strings
  "stringr", "glue",
  # Tabular operations
  "data.table", "dplyr",
  # Functional programming
  "magrittr", "future.apply",
  # Visualisation
  "ggplot2"
)

dynamicRequire(libs)
```

# Import data

Declare data source:

-   Whole Genome Shotgun (WGS)
-   Whole Transcriptome Shotgun (WTS)

```{r declare-data-source}
srctype <- c("WGS", "WTS") %>% 
  setNames(nm = .)
```

Import numeric data:

```{r numeric-data}
BINCOV <- fread("data/bin_coverage.txt")
COUNTS <- lapply(srctype, \(s) fread(glue("results/{s}_clean_count.tsv.gz")))
```

Import annotations:

```{r annotation-data}
ANNOTATION <- fread("results/curated_annotation_table.tsv")
CHECKM <- fread("results/hq_bins.checkm_data.txt.gz")
TAXONOMY <- fread("data/bin_taxonomy_final.txt")
CAZYME <- readRDS("data/curated_cazymes_substrates.rds")
METADATA <- fread("data/sample_metadata.txt")
SUMMARY <- lapply(srctype, \(s) fread(glue("results/{s}_count.tsv.summary")))
SUBSTRATE <- readxl::read_excel("data/curated_dbcansub_substrate_map_2.xlsx")
```

# Clean data

**ANNOTATION**

-   Remove weird `_pred` suffix in MAG names.

```{r clean-annotation}
ANNOTATION$bin <- str_remove(ANNOTATION$bin, "_pred$")
```

**BINCOV**

-   Rename columns
-   Coerce to matrix

```{r clean-cov}
setnames(BINCOV, \(nm) {
  case_when(
    str_detect(nm, "Filt") ~ str_replace(nm, "(.*)", "\\1_1"),
    str_detect(nm, "Sed") ~ str_remove(nm, "Sample"),
    .default = nm
  )
})
BINCOV <- as.matrix(BINCOV[, -1], rownames = BINCOV$bin)
```

**CHECKM**

-   Rename columns

```{r clean-checkm}
setnames(CHECKM, \(nm) str_replace(nm, " ", "_"))
```

**COUNTS**

-   Convert to matrix with node ID as rownames
-   Use `METADATA$sample` as the authoritative vector on samples and their naming convention

```{r clean-count}
COUNTS <- lapply(COUNTS, \(dt) {
  nm <- names(dt)[names(dt) %in% METADATA$sample]
  as.matrix(dt[, .SD, .SDcols = nm], rownames = dt$Geneid)
})
```

**SUMMARY**

-   Rename columns to retain only sample names.

```{r clean-map-summary}
SUMMARY <- lapply(SUMMARY, \(dt) {
  setnames(dt, \(nm) str_extract(nm, "(Filt|Sed).S\\d_\\d"))
})
```

**TAXONOMY**

-   Expand taxonomic levels
-   Remove irrelevant columns

```{r clean-taxa}
tax_level <- c("domain", "phylum", "class", "order", "family", "genus", "species")
TAXONOMY <- TAXONOMY[
  , (tax_level) := tstrsplit(gtdb_taxonomy, ";", fill = NA)
][
  , (tax_level) := lapply(.SD, \(s) gsub("[a-z]__", "", s)), .SDcols = tax_level
][
  , c("gtdb_taxonomy", "taxa") := NULL
]
```

**SUBSTRATE**

-   Coerce to data table

```{r clean-substrate}
setDT(SUBSTRATE)
```

**CAZYME**

-   Coerce to data table

```{r clean-cazyme}
setDT(CAZYME)
```

# Standard objects

**Habitat colour and shape**

-   [Sediment: `"#F89812"` solid triangle (17)]{style="color:#F89812;"}
-   [Water : `"#25A7F8"` solid circle (19)]{style="color:#25A7F8;"}

```{r}
habitat_colour <- c("sediment" = "#F89812", "water" = "#25A7F8")
habitat_shape = c("sediment" = 17, "water" = 19)
```

**Salinity gradient colours**

Viridis, palette D, where dark purple is non-saline and yellow is marine.

**CAZyme colours**

-   [GH: `"#CE1235"`]{style="color:#CE1235;"}
-   [PL: `"#59C9A5"`]{style="color:#59C9A5;"}

```{r}
cazyme_colour <- c("GH" = "#CE1235", "PL" = "#59C9A5")
```

**GH and PL encoding nodes**

```{r}
gp_node <- unique(CAZYME$NODE[grepl("(GH|PL)", CAZYME$FAMILY)])
```

**Samples shared between WTS and WGS**

```{r}
overlap_samples <- Reduce(intersect, lapply(COUNTS, colnames))
```

# Thresholding

Bin coverage: Retain MAGs with at least coverage of 1
Mapped genes and transcript: 

```{r}
BINCOV <- ifelse(BINCOV < 1, 0, BINCOV)
```

Examine mapping taking into account gene length (RPK)

```{r}
calcTPM <- function(m, gene.length) {
  # Calculate RPK first 
  # (gene length in kbp)
  rpk <- sweep(m, 1, gene.length/1e3, "/")
  
  # TPM from RPK 
  # (normalised to per million reads per kbp)
  sweep(rpk, 2, colSums(rpk)/1e6, "/")
}
geneLength <- with(ANNOTATION, end - start + 1)
TPM <- lapply(COUNTS, calcTPM, geneLength)
CPM <- lapply(COUNTS, edgeR::cpm.default)

for (i in 1:ncol(TPM$WTS)) {
  plot(y = TPM$WTS[, i], x = COUNTS$WTS[, i], 
       main = colnames(TPM$WTS)[i],
       ylab = "TPM", xlab = "Count")
  abline()
}



splitCount <- lapply(COUNTS, \(m) {
  list(
    "water" = m[, grepl("Filt", colnames(m))],
    "sediment" = m[, grepl("Sed", colnames(m))]
  )
}) %>% 
  unlist(recursive = FALSE)

RPK <- lapply(splitCount, \(m) {
  m <- calcRPK(m, geneLength)
  cond <- rownames(m) %in% unique(CAZYME$NODE) & rowSums(m) > 0
  m <- m[cond, ]
})

RPK2 <- lapply(splitCount, \(m) {
  pa <- ifelse(m > 0, 1, 0)
  cond <- rowSums(pa) == ncol(m)
  m[cond, ]
})

RPK3 <- lapply(RPK2, rowVars, std = TRUE)
```



