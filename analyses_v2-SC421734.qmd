---
title: "Analyses (ver. 2)"
author: "Jian Sheng Boey"
format: 
  html:
    fig-format: svg
    fig-width: 12
    fig-height: 9
execute: 
  cache: true
filters: 
  - include-code-files
---

# Environment

```{r libs}
dynamicRequire <- function(lib) {
  if (!require(lib, character.only = TRUE)) install.packages(lib)
  library(lib, character.only = TRUE, quietly = TRUE, verbose = FALSE)
  invisible(lib)
}
dynamicRequire <- Vectorize(dynamicRequire)

libs <- c(
  # Fast utilities
  "Rfast", "Rfast2",
  # Ecology
  "vegan",
  # Strings
  "stringr", "glue",
  # Tabular operations
  "data.table", "dplyr",
  # Functional programming
  "magrittr", "future.apply",
  # Visualisation
  "ggplot2"
)

dynamicRequire(libs)
rm(libs)
```

# Import data

Declare data source:

-   Whole Genome Shotgun (WGS)
-   Whole Transcriptome Shotgun (WTS)

```{r declare-data-source}
srctype <- c("WGS", "WTS") %>% 
  setNames(nm = .)
```

Import numeric data:

```{r numeric-data}
COUNTS <- lapply(srctype, \(s) fread(glue("results/{s}_clean_count.tsv.gz")))
CONTIGCOV <- lapply(srctype, \(s) fread(glue("data/{s}.contig_coverage.tsv")))
RLEN <- fread("data/read_lengths.csv") %>%
  split(., .$srctype)
```

Import annotations:

```{r annotation-data}
ANNOTATION <- fread("results/curated_annotation_table.tsv")
CHECKM <- fread("results/hq_bins.checkm_data.txt.gz")
TAXONOMY <- fread("data/bin_taxonomy_final.txt")
CAZYME <- as.data.table(readRDS("data/curated_cazymes_substrates.rds"))
METADATA <- fread("data/sample_metadata.txt")
SUMMARY <- lapply(srctype, \(s) fread(glue("results/{s}_count.tsv.summary")))
SUBSTRATE <- as.data.table(
  readxl::read_excel("data/curated_dbcansub_substrate_map_2.xlsx")
)
```

# Clean data

**ANNOTATION**

-   Remove weird `_pred` suffix in MAG names.

```{r clean-annotation}
ANNOTATION$bin <- str_remove(ANNOTATION$bin, "_pred$")
```

**CONTIGCOV**

- Split coverage and depth tables
- Fix column names

```{r clean-clen}
CONTIGCOV <- lapply(CONTIGCOV, \(dt) {
  names(dt)[1] <- "contig"
  l <- list(
    "covbases" = dt[, .SD, .SDcols = patterns("contig|covbases")],
    "numreads" = dt[, .SD, .SDcols = patterns("contig|numreads")]
  )
  l <- lapply(l, \(DT) {
    names(DT) <- str_remove_all(names(DT), "W[GT]S\\.|\\.(numreads|covbases)")
    return(DT)
  })
  return(l)
}) %>% 
  unlist(recursive = FALSE)
```


**CHECKM**

-   Rename columns

```{r clean-checkm}
setnames(CHECKM, \(nm) str_replace(nm, " ", "_"))
```

**COUNTS**

-   Convert to matrix with node ID as rownames
-   Use `METADATA$sample` as the authoritative vector on samples and their naming convention

```{r clean-count}
COUNTS <- lapply(COUNTS, \(dt) {
  nm <- names(dt)[names(dt) %in% METADATA$sample]
  as.matrix(dt[, .SD, .SDcols = nm], rownames = dt$Geneid)
})
```

**SUMMARY**

-   Rename columns to retain only sample names.

```{r clean-map-summary}
SUMMARY <- lapply(SUMMARY, \(dt) {
  setnames(dt, \(nm) str_extract(nm, "(Filt|Sed).S\\d_\\d"))
})
```

**TAXONOMY**

-   Expand taxonomic levels
-   Remove irrelevant columns

```{r clean-taxa}
tax_level <- c("domain", "phylum", "class", "order", "family", "genus", "species")
TAXONOMY <- TAXONOMY[
  , (tax_level) := tstrsplit(gtdb_taxonomy, ";", fill = NA)
][
  , (tax_level) := lapply(.SD, \(s) gsub("[a-z]__", "", s)), .SDcols = tax_level
][
  , c("gtdb_taxonomy", "taxa") := NULL
]
```

# Standard objects

**Habitat colour and shape**

-   [Sediment: `"#F89812"` solid triangle (17)]{style="color:#F89812;"}
-   [Water : `"#25A7F8"` solid circle (19)]{style="color:#25A7F8;"}

```{r set-habitat}
habitat_colour <- c("sediment" = "#F89812", "water" = "#25A7F8")
habitat_shape = c("sediment" = 17, "water" = 19)
```

**Salinity gradient colours**

Viridis, palette D, where dark purple is non-saline and yellow is marine.

**CAZyme colours**

-   [GH: `"#CE1235"`]{style="color:#CE1235;"}
-   [PL: `"#59C9A5"`]{style="color:#59C9A5;"}

```{r set-cazyme}
cazyme_colour <- c("GH" = "#CE1235", "PL" = "#59C9A5")
```

**GH and PL encoding nodes**

```{r set-gp}
gp_node <- unique(CAZYME$NODE[grepl("(GH|PL)", CAZYME$FAMILY)])
```

**Samples shared between WTS and WGS**

```{r set-wts-wgs-samples}
overlap_samples <- Reduce(intersect, lapply(COUNTS, colnames))
```

# Convenience functions

Return unique elements of a nested vector.

```{r f-unwrap}
unwrap <- function(l) unique(unlist(x))
```

Split a matrix row and column-wise using regex. Remove zero-sum rows when requested.

```{r f-splitMatrix}
splitMatrix <- function(m, cpattern, rpattern=NULL, rm.zero=FALSE) {
  if (!is.matrix(m) | !is.numeric(m))
    stop("Input must be a numeric matrix")
  
  m <- m[, grepl(cpattern, colnames(m))]
  
  if (!is.null(rpattern) & length(rpattern) == 1)
    m <- m[grepl(rpattern, rownames(m)), ]
  else
    m <- m[rownames(m) %in% rpattern, ]
  
  if (isTRUE(rm.zero))
    m <- m[rowSums(m) > 0, ]
  
  m
}
```

Extract contig length based on node/contig ID

```{r f-getContigLength}
getContigLength <- function(x) as.numeric(gsub(".*length_(\\d+)_.*", "\\1", x))
```

Perform `lapply()` at specified depth.

```{r f-lapplyAtDepth}
lapplyAtDepth <- function(LIST, DEPTH, FUN) {
  if (DEPTH == 1) {
    lapply(LIST, FUN)
  } else {
    lapply(LIST, function(l) lapplyAtDepth(l, DEPTH - 1, FUN))
  }
}
```

# Derived data

## MAG assembly and estimated genome size

Assembly size is the total contig size of a MAG.
Genome size is the assembly size corrected for completeness and contamination.

```{r genome-size}
bin2contig <- ANNOTATION[
  , .(bin, node)
][
  , `:=`(
    contig = gsub("_\\d+$", "", node),
    contig_size = getContigLength(node)
  )
][
  , node := NULL
] %>% 
  unique()

CHECKM[
  , assembly_size := sapply(Rename, \(x) sum(bin2contig[bin == x]$contig_size))
][
  , genome_size := (assembly_size * 100/Completeness) - (assembly_size * Contamination/100)
]
```


## MAG read coverage and relative abundance

Read coverage of a MAG in a sample is calculated based on the formula by [Lander and Waterman (1988)](https://doi.org/10.1016/0888-7543(88)90007-9).

$$
c = 
\frac
{\bar{l}N_{\textrm{MAG}}}
{G}
$$

- $\bar{l}$ is the average read length of the sample library
- $N_{\textrm{MAG}}$ is the number of reads mapped to a MAG in the sample library
- $G$ is the assembly size of the MAG, i.e., the sum of all contig lengths in a bin

```{r read-cov}
aveRLEN <- lapply(RLEN, \(dt) {
  DT <- copy(dt)
  DT <- DT[
    , .(x = sum(as.numeric(read_length) * count) / sum(count)), by = sample
  ]
  return(setNames(DT$x, DT$sample))
})

BINCOV <- mapply(
  \(dt, rlen) {
    DT <- na.omit(bin2contig[dt, on = c("contig")])
    DT[
      , lapply(.SD, sum), 
      .SDcols = patterns("contig_size|Sed|Filt"), 
      by = "bin"
    ][
      , lapply(.SD, \(x) x / contig_size),
      .SDcols = patterns("Sed|Filt"),
      by = "bin"
    ]
  },
  purrr::keep_at(CONTIGCOV, \(x) grepl("numreads", x)),
  aveRLEN,
  SIMPLIFY = FALSE
)

names(BINCOV) <- gsub(".numreads", "", names(BINCOV))
```

The relative abundance of the MAG in a sample is its read coverage normalised by the proportion of the reads in a sample library relative to the maximum library size across all samples.

$$
A_r =
\frac
{c\max N}
{N}
$$

- $\max N$ is the maximum number of reads across all sample libraries
- $N$ is the number of reads in a sample library

## Length-normalised transcript/Gene per million

First get reads per kilobase pair (RPK):

$$
\textrm{RPK} = \frac{N_g}{l_g}
$$

where

- $N_g$ is the number of reads aligned to gene
- $l_g$ is the gene length

Then normalised by RPK sum:

$$
\textrm{TPM} = \frac{RPK}{\sum{\textrm{RPK}}}
$$

```{r tpm}
calcTPM <- function(m, gene.length) {
  
  if (is.null(names(gene.length)))
    stop("Gene length vector needs gene ID for rownames matching")
  
  if (all(names(gene.length) != rownames(m)))
    gene.length <- gene.length[order(match(names(gene.length), rownames(m)))]
  
  if (all(names(gene.length) == rownames(m))) {
    rpk <- sweep(m, 1, gene.length/1e3, "/")
    sweep(rpk, 2, colsums(rpk)/1e6, "/")
  }
  
}

TPM <- lapply(COUNTS, \(m) {
  calcTPM(m, setNames(ANNOTATION %$% (end - start + 1), ANNOTATION$node))
})
```

## Genome size


