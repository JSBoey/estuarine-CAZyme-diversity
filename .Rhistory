source("C:/Users/jboe440/OneDrive/Current items/Projects/estuarine-CAZyme-diversity/docs/CAZyme_SparCC.R", echo=TRUE)
gc()
spieceasi_sediment <- spiec.easi(
t(sub_data$WTS$Sediment),
method = 'mb',
lambda.min.ratio = 50e-3,
nlambda = 20,
pulsar.params = list(
rep.num = 50
)
)
save.image("results/CAZyme_SPIEC-EASI.RData")
igMB <- list(
"Water" = adj2igraph(getRefit(spieceasi_water)),
"Sediment" = adj2igraph(getRefit(spieceasi_sediment))
)
library(igraph)
igCoord <- map(igMB, layout.fruchterman.reingold)
par(mfrow = c(1, 2))
pmap(list(igMB, igCoord, names(igCoord)), ~ {
main <- paste("SPIEC-EASI (MB) network of", ..3)
plot(..1, layout = ..2, vertex.size = 3, vertex.label = NA, main = main)
})
save.image("results/CAZyme_sparse_networks.RData")
# WGCNA ----
library(wgcna)
# WGCNA ----
library(WGCNA)
View(sub_data)
powers <- c(c(1:10), seq(12, 20, by = 2))
sft <- map(sub_data$WTS, ~ {
pickSoftThreshold(.x, powerVector = powers, verbose = 5)
})
pdf("results/CAZyme_SpiecEasi.pdf", width = 8, height = 4)
par(mfrow = c(1, 2))
pmap(list(igMB, igCoord, names(igCoord)), ~ {
main <- paste("SPIEC-EASI (MB) network of", ..3)
plot(..1, layout = ..2, vertex.size = 3, vertex.label = NA, main = main)
})
dev.off()
par(mfrow = c(2, 2))
map2(sft, names(sft), function(sft, nm) {
# Plot scale-free topology fit index as a function of soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence for", nm))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=0.9,col="red")
# Mean connectivity as a function of soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity for", nm))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
})
par(mfrow = c(2, 2))
map2(sft, names(sft), function(sft, nm) {
# Plot scale-free topology fit index as a function of soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence for", nm))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=0.9,col="red")
# Mean connectivity as a function of soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity for", nm))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.9,col="red")
})
powers <- c(c(1:20), seq(22, 40, by = 2))
sft <- map(sub_data$WTS, ~ {
pickSoftThreshold(.x, powerVector = powers, verbose = 5)
})
par(mfrow = c(2, 2))
map2(sft, names(sft), function(sft, nm) {
# Plot scale-free topology fit index as a function of soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence for", nm))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=0.9,col="red")
# Mean connectivity as a function of soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity for", nm))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.9,col="red")
})
sft <- map(sub_data$WTS, ~ {
pickSoftThreshold(t(.x), powerVector = powers, verbose = 5)
})
par(mfrow = c(2, 2))
map2(sft, names(sft), function(sft, nm) {
# Plot scale-free topology fit index as a function of soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence for", nm))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=0.9,col="red")
# Mean connectivity as a function of soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity for", nm))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.9,col="red")
})
net <- map2(sub_data$WTS, names(sub_data$WTS), ~ {
blockwiseModules(t(.x), power = 7,
TOMType = "unsigned", minModuleSize = 30,
reassignThreshold = 0, mergeCutHeight = 0.25,
numericLabels = TRUE, pamRespectsDendro = FALSE,
saveTOMs = TRUE,
saveTOMFileBase = paste0("CAZymeTOM", .y),
verbose = 3)
})
View(net)
net[["Sediment"]][["goodGenes"]]
net[["Sediment"]][["goodSamples"]]
net[["Sediment"]][["MEs"]][["ME0"]]
!require(edgeR)
if (!requireNamespace("edgeR", quietly = TRUE)) library(edgeR)
loadedNamespaces()
if (!requireNamespace("tidyverse", quietly = TRUE)) library(tidyverse)
loadedNamespaces()
# Environment ----
getwd()
# Environment ----
source("scripts/utility_functions.R")
# Data ----
dbcan <- read_tsv("results/allbins_pred.dbcan_parsed.tsv.gz", col_names = F)
# Environment ----
library(tidyverse)
# Data ----
dbcan <- read_tsv("results/allbins_pred.dbcan_parsed.tsv.gz", col_names = F)
wts_count <- read_tsv("results/WTS_clean_count.tsv.gz") |>
select(-contains("Filt"))
View(dbcan)
wts_count <- read_tsv("results/WTS_clean_count.tsv.gz") |>
select(-contains("Filt")) |>
filter(Geneid %In% dbcan$X1)
wts_count <- read_tsv("results/WTS_clean_count.tsv.gz") |>
select(-contains("Filt")) |>
filter(Geneid %in% dbcan$X1)
wts_summary <- read_tsv("results/WTS_count.tsv.summary") |>
rename_with(.fn = fcNameClean, .cols = -Status) |>
select(-contains("Filt"))
# Normalise data ----
tpm <- count2TPM(wts_count, wts_summary)
View(tpm)
# Normalise data ----
tpm <- count2TPM(wts_count, wts_summary) |>
filter(rowSums(select(., -Geneid)) > 0) # Filter out all zeroes
# Normalise data ----
tpm <- count2TPM(wts_count, wts_summary) |>
filter(rowSums(. == 0) < ncol(.))
# Normalise data ----
tpm <- count2TPM(wts_count, wts_summary) |>
filter(rowSums(.) > 0)
View(tpm)
# Normalise data ----
tpm <- count2TPM(wts_count, wts_summary) |>
filter(rowSums(select(., where(is.numeric))) > 0)
tpm <- filter(tpm, rowSums(select(tpm, -Geneid)) > 0)
View(tpm)
# CAZyme distribution ----
tpm |>
pivot_longer(-Geneid, names_to = "sample", values_to = "value") |>
ggplot(aes(x = value, colour = sample)) +
geom_density(linewidth = 1.5)
# CAZyme distribution ----
tpm |>
pivot_longer(-Geneid, names_to = "sample", values_to = "value") |>
ggplot(aes(x = log10(value), colour = sample)) +
geom_density(linewidth = 1.5)
?slice_max
# Top 1% of CAZymes ----
top_cazyme <- tpm |>
pivot_longer(-Geneid, names_to = "sample", values_to = "tpm") |>
group_by(sample) |>
filter(tpm > quantile(tpm, 0.99))
View(top_cazyme)
# Subset to non-GT CAZymes
depol_cazyme <- filter(dbcan, str_detect(X3, "GT", negate = T))
View(depol_cazyme)
# Top 1% of depolymerising CAZymes ----
top_cazyme <- tpm |>
filter(Geneid %in% depol_cazyme$X1) |>
pivot_longer(-Geneid, names_to = "sample", values_to = "tpm") |>
group_by(sample) |>
filter(tpm > quantile(tpm, 0.99))
View(top_cazyme)
# Top 1% of depolymerising CAZymes ----
top_nodes <- tpm |>
filter(Geneid %in% depol_cazyme$X1) |>
pivot_longer(-Geneid, names_to = "sample", values_to = "tpm") |>
group_by(sample) |>
filter(tpm > quantile(tpm, 0.99))
rm(top_cazyme)
top_tpm <- filter(tpm, Geneid %in% unique(top_nodes$Geneid))
View(top_tpm)
top_tpm <- filter(tpm, Geneid %in% unique(top_nodes$Geneid)) |>
left_join(dbcan, by = c("Geneid" = "X1"))
View(top_tpm)
top_tpm <- filter(tpm, Geneid %in% unique(top_nodes$Geneid)) |>
left_join(dbcan[, c("X1", "X3")], by = c("Geneid" = "X1"))
# Subset to depolymerising CAZymes ----
depol_cazyme <- filter(dbcan, str_detect(X3, "GH|PL"))
# Top 1% of depolymerising CAZymes ----
top_nodes <- tpm |>
filter(Geneid %in% depol_cazyme$X1) |>
pivot_longer(-Geneid, names_to = "sample", values_to = "tpm") |>
group_by(sample) |>
filter(tpm > quantile(tpm, 0.99))
top_tpm <- filter(tpm, Geneid %in% unique(top_nodes$Geneid)) |>
left_join(dbcan[, c("X1", "X3")], by = c("Geneid" = "X1"))
# Subset to depolymerising CAZymes ----
depol_cazyme <- filter(dbcan, str_detect(X3, "GH|PL")) |>
select(X1, X3)
length(unique(depol_cazyme$X1))
