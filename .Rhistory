lib.size <- colSums(makeCountMatrix(count_data))
}
# Convert to DGE list
dge <- DGEList(
counts = column_to_rownames(count_data, "Geneid"),
annotation.columns = c("Chr", "Start", "End", "Strand", "Length"),
lib.size = lib.size
)
# If require TMM library size normalization
if (method %in% c("tmm", "tmm_tpm")) {
dge <- calcNormFactors(dge, method = "TMM")
}
# Return TPM if asked
if (method %in% c("tpm", "tmm_tpm")) {
RPKM <- rpkm(dge)
norm_matrix <- t( t(RPKM) / colSums(RPKM) ) * 1e6
}
# Return TMM-normalised counts-per-million if requested
if (method == "tmm") {
norm_matrix <- cpm(dge, normalized.lib.sizes = TRUE, log = FALSE)
}
# Return gene length-normalised matrix
if (method == "rpk") {
norm_matrix <- sweep(getCounts(dge), 1, dge[["genes"]]$Length / 1000, "/")
}
return(norm_matrix)
}
norm_counts <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_methods, \(method) {
normaliseCounts(df, df_sum, method, "all")
})
})
norm_counts[["wgs"]][["RPK"]] |> view()
norm_counts <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_methods, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zdf <- subset(ncdf, subset = rowSums(ncdf) > 0)
})
})
View(norm_counts)
# CAZyme beta diversity
# Environment ----
library(vegan)
library(edgeR)
library(compositions)
library(tidyverse)
source("scripts/utility_functions.R")
# Data ----
env_data <- read_tsv("data/sample_metadata.txt")
dbcan <- read_tsv("results/clean.dbcan.tsv.gz")
callback <- DataFrameCallback$new(cazyFilter)
count_data <- list(
"wgs" = "results/WGS_clean_count.tsv.gz",
"wts" = "results/WTS_clean_count.tsv.gz"
) %>%
map(read_tsv_chunked, callback = callback)
count_summary <- list(
"wgs" = "results/WGS_count.tsv.summary",
"wts" = "results/WTS_count.tsv.summary"
) %>%
map(read_tsv) %>%
map(rename_with, fcNameClean)
# Normalise count data ----
norm_method <- c("tmm", "tpm", "tmm_tpm", "rpk") %>%
set_names(str_to_upper(.))
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_methods, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zdf <- subset(ncdf, subset = rowSums(ncdf) > 0)
})
})
?getCounts
# Methods are:
# - TPM (tpm)
# - TMM (tmm)
# - TPM with TMM normalised library size (tmm_tpm)
# - robust centered log ratio (rclr)
# - rCLR after gene length normalisation (trclr)
# Library size options:
# - All WTS reads (all): Obtain from mapping summary
# - Based on column sums of count data (csum)
# - Based on all mapped reads (mapped): Obtain from mapping summary
normaliseCounts <- function(count_data, mapping_summary, method, use.lib.size) {
if (!requireNamespace("tidyverse", quietly = TRUE)) library(tidyverse)
if (!requireNamespace("edgeR", quietly = TRUE)) library(edgeR)
if (!requireNamespace("vegan", quietly = TRUE)) library(vegan)
# Turn mapping summary into a matrix
mapping_summary <- column_to_rownames(mapping_summary, "Status") %>%
as.matrix()
# Library size
if (use.lib.size == "all") {
lib.size <- colSums(mapping_summary)
} else if (use.lib.size == "mapped") {
lib.size <- mapping_summary[1, ]
} else if (use.lib.size == "csum") {
lib.size <- colSums(makeCountMatrix(count_data))
}
# Convert to DGE list
dge <- DGEList(
counts = column_to_rownames(count_data, "Geneid"),
annotation.columns = c("Chr", "Start", "End", "Strand", "Length"),
lib.size = lib.size
)
# If require TMM library size normalization
if (method %in% c("tmm", "tmm_tpm")) {
dge <- calcNormFactors(dge, method = "TMM")
}
# Return TPM if requested
if (method %in% c("tpm", "tmm_tpm")) {
RPKM <- rpkm(dge)
norm_matrix <- t( t(RPKM) / colSums(RPKM) ) * 1e6
}
# Return TMM-normalised counts-per-million if requested
if (method == "tmm") {
norm_matrix <- cpm(dge, normalized.lib.sizes = TRUE, log = FALSE)
}
# If require gene length-normalisation (per kb) (i.e. normalised transcript)
if (method == "trclr") {
dge$counts <- sweep(getCounts(dge), 1, dge[["genes"]]$Length / 1000, "/")
}
# Return robust CLR if requested
if (method %in% c("rclr", "trclr")) {
norm_matrix <- decostand(getCounts(dge), method = "rclr", MARGIN = 2)
}
return(norm_matrix)
}
# Normalise count data ----
norm_method <- c("tmm", "tpm", "tmm_tpm", "rclr", "trclr") %>%
set_names(str_to_upper(.))
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_methods, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zdf <- subset(ncdf, subset = rowSums(ncdf) > 0)
})
})
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zdf <- subset(ncdf, subset = rowSums(ncdf) > 0)
})
})
View(norm_count)
norm_count[["wts"]][["RCLR"]]
# Methods are:
# - TPM (tpm)
# - TMM (tmm)
# - TPM with TMM normalised library size (tmm_tpm)
# - robust centered log ratio (rclr)
# - rCLR after gene length normalisation (trclr)
# Library size options:
# - All WTS reads (all): Obtain from mapping summary
# - Based on column sums of count data (csum)
# - Based on all mapped reads (mapped): Obtain from mapping summary
normaliseCounts <- function(count_data, mapping_summary, method, use.lib.size) {
if (!requireNamespace("tidyverse", quietly = TRUE)) library(tidyverse)
if (!requireNamespace("edgeR", quietly = TRUE)) library(edgeR)
if (!requireNamespace("vegan", quietly = TRUE)) library(vegan)
# Turn mapping summary into a matrix
mapping_summary <- column_to_rownames(mapping_summary, "Status") %>%
as.matrix()
# Library size
if (use.lib.size == "all") {
lib.size <- colSums(mapping_summary)
} else if (use.lib.size == "mapped") {
lib.size <- mapping_summary[1, ]
} else if (use.lib.size == "csum") {
lib.size <- colSums(makeCountMatrix(count_data))
}
# Convert to DGE list
dge <- DGEList(
counts = column_to_rownames(count_data, "Geneid"),
annotation.columns = c("Chr", "Start", "End", "Strand", "Length"),
lib.size = lib.size
)
# If require TMM library size normalization
if (method %in% c("tmm", "tmm_tpm")) {
dge <- calcNormFactors(dge, method = "TMM")
}
# Return TPM if requested
if (method %in% c("tpm", "tmm_tpm")) {
RPKM <- rpkm(dge)
norm_matrix <- t( t(RPKM) / colSums(RPKM) ) * 1e6
}
# Return TMM-normalised counts-per-million if requested
if (method == "tmm") {
norm_matrix <- cpm(dge, normalized.lib.sizes = TRUE, log = FALSE)
}
# If require gene length-normalisation (per kb) (i.e. normalised transcript)
if (method == "trclr") {
dge[["counts"]] <- sweep(getCounts(dge), 1, (dge[["genes"]]$Length / 1000), "/")
}
# Return robust CLR if requested
if (method %in% c("rclr", "trclr")) {
norm_matrix <- decostand(getCounts(dge), method = "rclr", MARGIN = 2)
}
return(norm_matrix)
}
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zdf <- subset(ncdf, subset = rowSums(ncdf) > 0)
})
})
View(norm_count)
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
zdf <- subset(df, subset = rowSums(ncdf) > 0)
ncdf <- normaliseCounts(zdf, df_sum, method, "all")
})
})
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
zdf <- subset(df, subset = rowSums(df) > 0)
ncdf <- normaliseCounts(zdf, df_sum, method, "all")
})
})
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
zero_genes <- rownames(makeCountMatrix(df))[rowSums(makeCountMatrix(df)) == 0]
zdf <- filter(df, !Geneid %in% zero_genes)
ncdf <- normaliseCounts(zdf, df_sum, method, "all")
})
})
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zncdf <- subset(ncdf, subset = rowSums(abs(ncdf)) > 0)
})
})
norm_count[["wts"]][["TMM"]]
?prcomp
compositions::princomp.acomp()
compositions::princomp.acomp
?compositions::princomp
?compositions::princomp.rmult
?gsi.getD
acomp(norm_count$wgs$RCLR)
?cegdist
?vegdist
acomp
acomp(makeCountMatrix(count_data$wts))
acomp(makeCountMatrix(count_data$wts)) %>% attr(., "center")
acomp(makeCountMatrix(count_data$wts)) %>% var(., robust, giveCenter = TRUE)
acomp(makeCountMatrix(count_data$wts)) %>% var(., robust = robust, giveCenter = TRUE)
acomp(makeCountMatrix(count_data$wts)) %>% var(., robust = getOption("robust"), giveCenter = TRUE)
acomp(makeCountMatrix(count_data$wts)) %>% var(.)
acomp(makeCountMatrix(count_data$wts)) %>% var(., na.rm = TRUE)
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE, robust = robust)
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE, robust = robust)
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE, robust = "robust")
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE)
?stats::var
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE, use = "pairwise.complete.obs")
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(., giveCenter = TRUE, use = "complete.obs")
acomp(makeCountMatrix(count_data$wts)) %>% var.acomp(t(.), giveCenter = TRUE, use = "pairwise.complete.obs")
?match.call
vegdist
decostand
.calc_rclr
vegan:::.calc_rclr
vegdist
vegan:::do_vegdist
.Call(vegan:::do_vegdist)
.Call(vegan:::do_vegdist, x, 22)
.Call(vegan:::do_vegdist, count_data$wts, 22)
.Call(vegan:::do_vegdist, makeCountMatrix(count_data$wts), 22)
.Call(vegan:::do_vegdist, t(makeCountMatrix(count_data$wts)), 22)
install.packages("ROptSpace")
vegan:::.fill.OptSpace
?ROptSpace::OptSpace()
library(ROptSpace)
# Matrix completion for rCLR transformed data ----
norm_count <- map(norm_count, \(l) {
map_at(l, c("RCLR", "TRCLR"), \(m) {
m[m == 0] <- NA
OptSpace(m)
})
})
View(norm_count)
with(norm_count$wgs$RCLR, norm(X%*%S%*%t(Y) - decostand(makeCountMatrix(count_data$wgs), method = "rclr", MARGIN = 2), 'f'))
View(count_data)
with(norm_count$wgs$RCLR, norm(X%*%S%*%t(Y) - decostand(makeCountMatrix(count_data$wgs), method = "rclr", MARGIN = 2), 'f')) / sqrt(17338 * 42)
?vegdist
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zncdf <- subset(ncdf, subset = rowSums(abs(ncdf)) > 0)
})
})
princomp
methods(princomp)
stats::princomp
methods(stats::princomp)
?methods
getS3method("stats::princomp")
getS3method(princomp)
getS3method("princomp")
getS3method("princomp", class = "function")
getS3method("princomp", class = "default*")
getS3method("princomp", class = "default")
# Matrix completion with OptSpace ----
completeMatrix <- function(m) {
# Set zeroes to NA
m[m == 0] <- NA
# Run OptSpace
op <- OptSpace(m)
# Get completed matrix
M <- with(op, X %*% S %*% t(Y))
# Fill matrix
m[is.na(m), is.na(m)] <- M[is.na(m), is.na(m)]
return(m)
}
test <- decostand(makeCountMatrix(count_data$wts[1:10, 1:10]), method = "rclr", MARGIN = 2)
test <- decostand(makeCountMatrix(count_data$wts)[1:10, 1:10], method = "rclr", MARGIN = 2)
test <- decostand(makeCountMatrix(count_data$wts)[1:20, 1:20], method = "rclr", MARGIN = 2)
makeCountMatrix(count_data$wts)[1:20, 1:20]
test_matrix <- makeCountMatrix(count_data$wts)[1:20, 1:20]
test_matrix <- subset(test_matrix, select = colSums(test_matrix) > 0)
test_rclr <- decostand(test_matrix, "rclr", 2)
test_cm <- completeMatrix(test_rclr)
# Matrix completion with OptSpace ----
completeMatrix <- function(m) {
# Set zeroes to NA
m[m == 0] <- NA
# Run OptSpace
op <- OptSpace(m)
# Get completed matrix
M <- with(op, X %*% S %*% t(Y))
# Fill matrix
m[is.na(m) == TRUE] <- M[is.na(m) == TRUE]
return(m)
}
test_cm <- completeMatrix(test_rclr)
test_matrix
test_rclr
test_cm
test_matrix <- subset(test_matrix, select = colSums(test_matrix) > 0, subset = rowSums(test_matrix) > 0)
test_cm <- completeMatrix(test_rclr)
test_rclr <- decostand(test_matrix, 'rclr', 2)
test_cm <- completeMatrix(test_rclr)
test_matrix
round(test_rclr, 2)
round(test_cm, 2)
# Matrix completion for rCLR transformed data ----
norm_count <- map(norm_count, \(l) {
complete_rclr <- l[[c("rclr", "trclr")]]
})
norm_count <- map2(count_data, count_summary, \(df, df_sum) {
map(norm_method, \(method) {
ncdf <- normaliseCounts(df, df_sum, method, "all")
zncdf <- subset(ncdf, subset = rowSums(abs(ncdf)) > 0)
})
})
# Matrix completion for rCLR transformed data ----
norm_count_2 <- map(norm_count, \(l) {
complete_rclr <- l[[c("rclr", "trclr")]]
})
# Matrix completion for rCLR transformed data ----
norm_count_2 <- map(norm_count, \(l) {
complete_rclr <- l[c("rclr", "trclr")]
})
View(norm_count_2)
# Matrix completion for rCLR transformed data ----
norm_count_2 <- map(norm_count, \(l) {
complete_rclr <- l[[c("rclr", "trclr")]]
})
# Matrix completion for rCLR transformed data ----
norm_count_2 <- map(norm_count, \(l) {
complete_rclr <- l[[c("RCLR", "TRCLR")]]
})
# Matrix completion for rCLR transformed data ----
norm_count_2 <- map(norm_count, \(l) {
complete_rclr <- l[c("RCLR", "TRCLR")]
})
View(norm_count_2)
# Matrix completion for rCLR transformed data ----
norm_count <- map(norm_count, \(l) {
complete_rclr <- map(l[c("RCLR", "TRCLR")], completeMatrix)
names(complete_rclr) <- paste0(names(complete_rclr), "_COMP")
append(l, complete_rclr)
})
View(norm_count)
norm_count[["wgs"]][["RCLR_COMP"]]
completeMatrix(norm_count$wts$RCLR)
names(norm_counts$wts)
names(norm_count$wts)
# Calculate distances ----
## For TPM, TMM, TMM_TPM, use Bray-Curtis
## For rCLR and trCLR, use Euclidean
D <- map(norm_count, \(x) {
map2(x, names(x), \(m, nm) {
if (nm %in% c("TMM", "TPM", "TMM_TPM")) {
vegdist(t(m), method = "bray")
} else {
vegdist(t(m), method = "euclidean")
}
})
})
View(D)
D[["wgs"]][["TMM"]]
D[["wgs"]][["RCLR_COMP"]]
# Compare distances ----
dist_compare <- map(D, \(d) {
method <- names(d)
combination <- as.data.frame(t(combn(method)))
combination %>%
mutate(
test = map2(V1, V2, ~ cor.test(d[.x], d[.y])),
rho = map(test, "estimate"),
p.value = map(test, "p.value")
)
})
# Compare distances ----
dist_compare <- map(D, \(d) {
method <- names(d)
combination <- as.data.frame(t(combn(method, 2)))
combination %>%
mutate(
test = map2(V1, V2, ~ cor.test(d[.x], d[.y])),
rho = map(test, "estimate"),
p.value = map(test, "p.value")
)
})
# Compare distances ----
dist_compare <- map(D, \(d) {
method <- names(d)
combination <- as.data.frame(t(combn(method, 2)))
combination %>%
mutate(
test = map2(V1, V2, ~ cor.test(d[[.x]], d[[.y]])),
rho = map(test, "estimate"),
p.value = map(test, "p.value")
)
})
View(dist_compare)
View(dist_compare[["wgs"]])
# Compare distances ----
dist_compare <- map(D, \(d) {
method <- names(d)
combination <- as.data.frame(t(combn(method, 2)))
combination %>%
mutate(
test = map2(V1, V2, ~ cor.test(d[[.x]], d[[.y]])),
rho = map_dbl(test, "estimate"),
p.value = map_dbl(test, "p.value")
)
})
View(dist_compare[["wgs"]])
# Compare distances ----
dist_compare <- map(D, \(d) {
method <- names(d)
combination <- as.data.frame(t(combn(method, 2)))
combination %>%
mutate(
test = map2(V1, V2, ~ cor.test(d[[.x]], d[[.y]])),
rho = map_dbl(test, "estimate"),
p.value = map_dbl(test, "p.value")
) %>%
select(-test)
})
View(dist_compare[["wgs"]])
ggplot(dist_compare$wgs, aes(x = V1, y = V2, fill = rho)) +
geom_tile()
ggplot(dist_compare$wgs, aes(x = V1, y = V2, fill = rho, alpha = p.value)) +
geom_tile()
ggplot(dist_compare$wgs, aes(x = V1, y = V2, fill = rho, alpha = -log10(p.value))) +
geom_tile()
ggplot(dist_compare$wgs, aes(x = V1, y = V2, fill = rho, alpha = -log10(p.value + 1))) +
geom_tile()
ggplot(dist_compare$wgs, aes(x = V1, y = V2, fill = rho)) +
geom_tile()
library(KEGGREST)
iris2
iris
data <- iris
fr <- c("Sepal.length", "Sepal.length + Sepal.Width", "Sepal.length + Sepal.Width + Species")
for (i in 1:length(fr)) {
f <- formula(paste0("Petal.Length ~ ", fr[i]))
mod <- lm(f, data)
summary(mod)
}
fr <- c(
"Sepal.Length",
"Sepal.Length + Sepal.Width",
"Sepal.Length + Sepal.Width + Species"
)
for (i in 1:length(fr)) {
f <- formula(paste0("Petal.Length ~ ", fr[i]))
mod <- lm(f, data)
summary(mod)
}
View(mod)
for (i in 1:length(fr)) {
f <- formula(paste0("Petal.Length ~ ", fr[i]))
mod <- lm(f, data)
print(summary(mod))
}
View(data)
sweep(data[, 1:4], 1, rowSums(data[, 1:4]), "/")
sweep(data[, 1:4], 1, rowMeans(data[, 1:4]), "/")
sweep(data[, 1:4], 1, colMeans(data[, 1:4]), "/")
sweep(data[, 1:4], 1, rowMeans(data[, 1:4]), "/")
?dplyr::near
vegan::diversity
vegan::radfit
methods("vegan::radfit")
methods(radfit)
methods("radfit")
UseMethod("radfit")
showMethods("vegan::radfit")
showMethods("vegan::radfit", classes = "S3")
?switch
